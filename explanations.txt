SOLUTION 1.
The solution is based on the clear reasons:

- creating the lists of elements from both strings list() is needed for analysis;
- the use the boolean AND np.logical_and() gives the result "True" if all symbols from the second string are in the first one;
- the list of indices of the first string for elements from the second string is made in the same loop;
- applying functions for the indices [sum(), map(), abs(), .diff()] helps to find exactly anagrams: if sorted indices have the absolute values of differences 1 and therefore symbols from the second string stand consecutively in the first one then the function returns "True".

Efficiency:
Q((n^2)*m), where n - the length of s and m - the length of t.

SOLUTION 2.
In this case, the solution includes several helper functions. 
It's the most convenient way for me to build every step as a separate function in the logical order. 
For all helper functions, I try to find the easiest and quickest way for every concrete operation.
The final function indicates that the word 'a' consists of one letter and can be considered as a palindrome.

Efficiency:
Q(  ), where n - the length of a.

SOLUTION 3.





SOLUTION 4.





SOLUTION 5.

